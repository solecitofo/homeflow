MOTOR DE DECISI√ìN: L√ìGICA DE RECOMENDACI√ìN
Este es el cerebro del sistema. Decide qu√© sugerir seg√∫n el contexto.
Algoritmo de Recomendaci√≥n

class TaskRecommendationEngine {
  
  /**
   * Funci√≥n principal: recomienda tarea seg√∫n estado del usuario
   */
  async recommendTask(
    userState: UserState,
    userPatterns: UserPatterns,
    homeConfig: HomeConfig,
    activityHistory: ActivityLog[]
  ): Promise<Task> {
    
    // PASO 1: Determinar estrategia TCC seg√∫n estado emocional
    const strategy = this.selectTCCStrategy(userState);
    
    // PASO 2: Filtrar tareas disponibles seg√∫n estrategia
    const candidateTasks = await this.filterTasksByStrategy(
      strategy,
      userState,
      homeConfig
    );
    
    // PASO 3: Scoring de tareas seg√∫n m√∫ltiples criterios
    const scoredTasks = this.scoreTasks(
      candidateTasks,
      userState,
      userPatterns,
      activityHistory
    );
    
    // PASO 4: Seleccionar la mejor opci√≥n
    return scoredTasks[0];
  }
  
  /**
   * PASO 1: Seleccionar estrategia TCC
   */
  private selectTCCStrategy(userState: UserState): TCCStrategy {
    
    // RUTA A: Usuario abrumado
    if (userState.emotionalState === 'overwhelmed') {
      return {
        name: 'micro_activation',
        principles: [
          'minimize_cognitive_load',
          'immediate_action',
          'no_choice_paralysis'
        ],
        filters: {
          isMicroTask: true,
          maxMinutes: 5,
          requiresDecisions: false,
          effortLevel: 'micro'
        }
      };
    }
    
    // RUTA B: Usuario con energ√≠a
    if (userState.emotionalState === 'energized' && userState.energyLevel === 'high') {
      return {
        name: 'capitalize_activation',
        principles: [
          'maximize_impact',
          'leverage_momentum',
          'high_reinforcement_tasks'
        ],
        filters: {
          maxMinutes: userState.availableTime || 20,
          impactLevel: ['medium', 'high'],
          // Priorizar tareas que hist√≥ricamente generan satisfacci√≥n
        }
      };
    }
    
    // RUTA C: Usuario bloqueado/estancado
    if (userState.emotionalState === 'stuck') {
      
      // Sub-estrategia seg√∫n la barrera espec√≠fica
      if (userState.barrier === 'no_energy') {
        return {
          name: 'low_effort_activation',
          principles: ['minimize_physical_effort', 'mental_tasks_ok'],
          filters: {
            requiresMovement: false,
            effortLevel: ['micro', 'low'],
            category: ['organizing', 'shopping'] // planificar, no ejecutar
          }
        };
      }
      
      if (userState.barrier === 'dont_know_what') {
        return {
          name: 'remove_choice',
          principles: ['provide_direction', 'random_ok'],
          filters: {
            // Cualquier tarea de bajo esfuerzo
            effortLevel: ['micro', 'low']
          }
        };
      }
      
      if (userState.barrier === 'perfectionism') {
        return {
          name: 'challenge_perfectionism',
          principles: ['emphasize_progress_over_perfection', 'time_boxing'],
          filters: {
            // Tareas con niveles de intensidad claros
            intensityLevels: 'exists'
          },
          messaging: {
            preTask: 'Recuerda: solo vas a hacer el nivel B√ÅSICO. Hecho es mejor que perfecto.',
            emphasizeBasicLevel: true
          }
        };
      }
      
      if (userState.barrier === 'anxiety') {
        return {
          name: 'reduce_anxiety',
          principles: ['familiar_tasks', 'high_success_rate'],
          filters: {
            // Tareas que el usuario ha completado antes con √©xito
            previouslyCompleted: true,
            effortLevel: ['micro', 'low']
          }
        };
      }
    }
    
    // RUTA D: Estado neutral / planificaci√≥n
    return {
      name: 'planned_activation',
      principles: ['user_directed', 'show_options'],
      filters: {} // Sin filtros restrictivos
    };
  }
  
  /**
   * PASO 2: Filtrar tareas disponibles
   */
  private async filterTasksByStrategy(
    strategy: TCCStrategy,
    userState: UserState,
    homeConfig: HomeConfig
  ): Promise<Task[]> {
    
    let allTasks = await this.getAllAvailableTasks(homeConfig);
    
    // Aplicar filtros de la estrategia
    let filtered = allTasks.filter(task => {
      
      // Filtro: micro-tareas
      if (strategy.filters.isMicroTask !== undefined) {
        if (task.isMicroTask !== strategy.filters.isMicroTask) return false;
      }
      
      // Filtro: duraci√≥n m√°xima
      if (strategy.filters.maxMinutes) {
        if (task.estimatedMinutes > strategy.filters.maxMinutes) return false;
      }
      
      // Filtro: nivel de esfuerzo
      if (strategy.filters.effortLevel) {
        const allowedLevels = Array.isArray(strategy.filters.effortLevel) 
          ? strategy.filters.effortLevel 
          : [strategy.filters.effortLevel];
        if (!allowedLevels.includes(task.effortLevel)) return false;
      }
      
      // Filtro: requiere decisiones
      if (strategy.filters.requiresDecisions === false) {
        if (task.requiresDecisions) return false;
      }
      
      // Filtro: requiere movimiento
      if (strategy.filters.requiresMovement === false) {
        if (task.requiresMovement) return false;
      }
      
      // Filtro: categor√≠as espec√≠ficas
      if (strategy.filters.category) {
        const allowedCategories = Array.isArray(strategy.filters.category)
          ? strategy.filters.category
          : [strategy.filters.category];
        if (!allowedCategories.includes(task.category)) return false;
      }
      
      // Filtro: nivel de impacto
      if (strategy.filters.impactLevel) {
        const allowedImpacts = Array.isArray(strategy.filters.impactLevel)
          ? strategy.filters.impactLevel
          : [strategy.filters.impactLevel];
        if (!allowedImpacts.includes(task.impactLevel)) return false;
      }
      
      // Filtro: tiene niveles de intensidad
      if (strategy.filters.intensityLevels === 'exists') {
        if (!task.intensityLevels) return false;
      }
      
      return true;
    });
    
    return filtered;
  }
  
  /**
   * PASO 3: Scoring de tareas (Machine Learning light)
   */
  private scoreTasks(
    tasks: Task[],
    userState: UserState,
    userPatterns: UserPatterns,
    activityHistory: ActivityLog[]
  ): Task[] {
    
    const scoredTasks = tasks.map(task => {
      let score = 0;
      
      // Factor 1: Historial de impacto emocional (PESO ALTO)
      const taskPattern = userPatterns.highImpactTasks.find(
        p => p.taskId === task.id
      );
      if (taskPattern) {
        score += taskPattern.averageMoodImprovement * 30; // peso x30
        score += taskPattern.completionRate * 20; // peso x20
      }
      
      // Factor 2: Alineaci√≥n con patrones temporales
      const currentHour = new Date().getHours();
      if (userPatterns.bestTimeOfDay) {
        const isOptimalTime = this.checkOptimalTime(currentHour, userPatterns.bestTimeOfDay);
        if (isOptimalTime) score += 15;
      }
      
      // Factor 3: Urgencia (√∫ltima vez realizada)
      const room = task.room;
      if (room) {
        const roomConfig = homeConfig.rooms.find(r => r.id === room);
        if (roomConfig?.lastCleaned) {
          const daysSince = this.daysSince(roomConfig.lastCleaned);
          score += Math.min(daysSince * 2, 20); // max 20 puntos
        }
      }
      
      // Factor 4: Impacto visual/emocional
      if (task.impactLevel === 'high') score += 15;
      if (task.impactLevel === 'medium') score += 8;
      
      // Factor 5: Duraci√≥n vs tiempo disponible (ajuste perfecto)
      if (userState.availableTime) {
        const timeFit = Math.abs(task.estimatedMinutes - userState.availableTime);
        score += Math.max(10 - timeFit, 0); // penaliza desajuste
      }
      
      // Factor 6: Evitar tareas recientemente completadas (variedad)
      const recentlyDone = activityHistory
        .filter(log => log.taskId === task.id)
        .sort((a, b) => b.startTime.getTime() - a.startTime.getTime())[0];
      
      if (recentlyDone) {
        const hoursSince = this.hoursSince(recentlyDone.startTime);
        if (hoursSince < 24) score -= 20; // penaliza mucho
        else if (hoursSince < 72) score -= 10; // penaliza moderado
      }
      
      // Factor 7: Preferencia de duraci√≥n detectada
      if (userPatterns.preferredTaskDuration) {
        const durationDiff = Math.abs(task.estimatedMinutes - userPatterns.preferredTaskDuration);
        score += Math.max(10 - durationDiff / 2, 0);
      }
      
      return { task, score };
    });
    
    // Ordenar por score descendente
    return scoredTasks
      .sort((a, b) => b.score - a.score)
      .map(item => item.task);
  }
  
  /**
   * M√©todos auxiliares
   */
  private async getAllAvailableTasks(homeConfig: HomeConfig): Promise<Task[]> {
    // Combina:
    // 1. Tareas predefinidas del sistema (biblioteca de tareas)
    // 2. Tareas personalizadas del usuario
    // 3. Tareas generadas din√°micamente seg√∫n estado del hogar
  }
  
  private daysSince(date: Date): number {
    return Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60 * 24));
  }
  
  private hoursSince(date: Date): number {
    return Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60));
  }
  
  private checkOptimalTime(currentHour: number, bestTime: string): boolean {
    const ranges = {
      morning: [6, 12],
      afternoon: [12, 18],
      evening: [18, 23]
    };
    const [start, end] = ranges[bestTime];
    return currentHour >= start && currentHour < end;
  }
}

FLUJO DE INTERACCI√ìN USUARIO-SISTEMA
Pantalla de entrada


// Componente: HomeManagementEntry.tsx

function HomeManagementEntry() {
  const [userState, setUserState] = useState<UserState | null>(null);
  
  const handleStateSelection = async (emotionalState: string) => {
    
    // Capturar estado inicial
    const state: UserState = {
      timestamp: new Date(),
      emotionalState: emotionalState as any,
    };
    
    // Si es "energized" o "stuck", hacer preguntas de seguimiento
    if (emotionalState === 'energized') {
      // Modal: "¬øCu√°nto tiempo tienes?"
      const time = await askAvailableTime();
      state.availableTime = time;
      state.energyLevel = 'high';
    }
    
    if (emotionalState === 'stuck') {
      // Modal: "¬øQu√© te est√° frenando?"
      const barrier = await askBarrier();
      state.barrier = barrier;
    }
    
    setUserState(state);
    
    // Obtener recomendaci√≥n del motor
    const recommendation = await getTaskRecommendation(state);
    
    // Navegar a pantalla de tarea recomendada
    navigate('/home/task-suggestion', { state: { recommendation, userState: state } });
  };
  
  return (
    <div className="entry-screen">
      <h2>¬øC√≥mo puedo ayudarte hoy?</h2>
      
      <StateCard 
        icon="ü§Ø"
        title="Estoy abrumado/a"
        subtitle="No s√© ni por d√≥nde empezar"
        onClick={() => handleStateSelection('overwhelmed')}
      />
      
      <StateCard 
        icon="‚ö°"
        title="Tengo algo de energ√≠a"
        subtitle="¬øQu√© puedo hacer?"
        onClick={() => handleStateSelection('energized')}
      />
      
      <StateCard 
        icon="üòì"
        title="Me cuesta ponerme en marcha"
        subtitle="Necesito un empuj√≥n"
        onClick={() => handleStateSelection('stuck')}
      />
      
      <StateCard 
        icon="üìù"
        title="Quiero planificar"
        subtitle="Ver opciones y decidir"
        onClick={() => navigate('/home/overview')}
      />
    </div>
  );
}
Pantalla de tarea sugerida
// Componente: TaskSuggestion.tsx

function TaskSuggestion() {
  const { recommendation, userState } = useLocation().state;
  const [taskStarted, setTaskStarted] = useState(false);
  const [timer, setTimer] = useState<number>(0);
  
  const handleStart = async () => {
    // Registrar inicio de actividad
    const activityLog: ActivityLog = {
      id: generateId(),
      userId: currentUser.id,
      taskId: recommendation.id,
      startTime: new Date(),
      startEmotionalState: await captureEmotionalState(),
      triggeredBy: 'system_suggestion',
      routeUsed: userState.emotionalState,
      completed: false,
    };
    
    await saveActivityLog(activityLog);
    
    setTaskStarted(true);
    startTimer(recommendation.estimatedMinutes);
  };
  
  const handleComplete = async () => {
    // Registrar finalizaci√≥n
    const endState = await captureEmotionalState();
    
    await updateActivityLog({
      completed: true,
      endTime: new Date(),
      actualMinutes: timer,
      endEmotionalState: endState,
    });
    
    // Mostrar feedback
    navigate('/home/task-feedback', { state: { activityLog } });
  };
  
  return (
    <div className="task-suggestion">
      {/* Mensaje personalizado seg√∫n estrategia TCC */}
      <TCCMessage strategy={recommendation.strategy} />
      
      <TaskCard task={recommendation} />
      
      {/* Si es estrategia de perfeccionismo */}
      {recommendation.strategy === 'challenge_perfectionism' && (
        <IntensitySelector 
          levels={recommendation.intensityLevels}
          defaultLevel="basic"
          emphasizeBasic={true}
        />
      )}
      
      {!taskStarted ? (
        <>
          <Button onClick={handleStart}>Empezar</Button>
          <Button variant="secondary" onClick={askForAlternative}>
            Dame otra opci√≥n
          </Button>
          {userState.emotionalState === 'overwhelmed' && (
            <Button variant="text" onClick={requestSmallerTask}>
              Necesito algo m√°s peque√±o
            </Button>
          )}
        </>
      ) : (
        <>
          <Timer minutes={timer} />
          <Checklist items={recommendation.steps} />
          <Button onClick={handleComplete}>¬°Hecho!</Button>
        </>
      )}
    </div>
  );
}

Pantalla de feedback post-tarea

// Componente: TaskFeedback.tsx

function TaskFeedback() {
  const { activityLog } = useLocation().state;
  
  const handleFeedback = async (feedback: FeedbackData) => {
    // Actualizar log con satisfacci√≥n y estado final
    await updateActivityLog({
      ...activityLog,
      satisfactionRating: feedback.satisfaction,
      endEnergyLevel: feedback.energyLevel,
    });
    
    // Actualizar patrones del usuario
    await updateUserPatterns(activityLog, feedback);
    
    // Preguntar si quiere hacer otra tarea
    showNextActionPrompt();
  };
  
  return (
    <div className="task-feedback">
      <SuccessAnimation />
      
      <h2>‚ú® ¬°Lo hiciste!</h2>
      
      <p>Completaste: {activityLog.task.title}</p>
      <p>en {activityLog.actualMinutes} minutos</p>
      
      <MoodComparison 
        before={activityLog.startEmotionalState}
        after={activityLog.endEmotionalState}
      />
      
      <FeedbackForm onSubmit={handleFeedback} />
      
      <StreakIndicator currentStreak={currentStreak} />
    </div>
  );
}

APRENDIZAJE CONTINUO DEL SISTEMA
/**
 * Actualiza los patrones del usuario despu√©s de cada actividad
 */
async function updateUserPatterns(
  activityLog: ActivityLog,
  feedback: FeedbackData
) {
  const patterns = await getUserPatterns(activityLog.userId);
  
  // 1. Detectar ventanas de activaci√≥n √≥ptimas
  const hour = activityLog.startTime.getHours();
  const timeOfDay = getTimeOfDay(hour);
  
  if (activityLog.completed && feedback.satisfaction >= 4) {
    patterns.successfulTimeSlots = patterns.successfulTimeSlots || {};
    patterns.successfulTimeSlots[timeOfDay] = 
      (patterns.successfulTimeSlots[timeOfDay] || 0) + 1;
  }
  
  // 2. Actualizar tareas de alto impacto
  if (feedback.moodImprovement > 0) {
    const taskPattern = patterns.highImpactTasks.find(
      t => t.taskId === activityLog.taskId
    );
    
    if (taskPattern) {
      // Actualizar promedio m√≥vil
      taskPattern.averageMoodImprovement = 
        (taskPattern.averageMoodImprovement * 0.8) + (feedback.moodImprovement * 0.2);
    } else {
      patterns.highImpactTasks.push({
        taskId: activityLog.taskId,
        averageMoodImprovement: feedback.moodImprovement,
        completionRate: 1.0,
      });
    }
  }
  
  // 3. Detectar duraci√≥n preferida
  if (activityLog.completed) {
    patterns.taskDurations = patterns.taskDurations || [];
    patterns.taskDurations.push(activityLog.actualMinutes);
    
    // Calcular mediana de las √∫ltimas 10 tareas
    if (patterns.taskDurations.length > 10) {
      patterns.preferredTaskDuration = median(patterns.taskDurations.slice(-10));
    }
  }
  
  // 4. Actualizar racha
  const today = new Date().toDateString();
  const lastActivity = patterns.lastActivityDate?.toDateString();
  
  if (lastActivity === today) {
    // Mismo d√≠a, no cambiar racha
  } else if (wasYesterday(patterns.lastActivityDate)) {
    patterns.currentStreak += 1;
    patterns.longestStreak = Math.max(patterns.currentStreak, patterns.longestStreak);
  } else {
    patterns.currentStreak = 1; // Reset
  }
  
  patterns.lastActivityDate = new Date();
  
  await saveUserPatterns(patterns);
}

BIBLIOTECA DE TAREAS PREDEFINIDAS

// tasks-library.ts

export const TASKS_LIBRARY: Task[] = [
  // ========= MICRO-TAREAS (para estado "overwhelmed") =========
  {
    id: 'micro_pickup_3_objects',
    category: 'organizing',
    title: 'Recoge 3 objetos',
    description: 'Encuentra 3 objetos que est√©n fuera de su sitio y col√≥calos donde van',
    estimatedMinutes: 2,
    effortLevel: 'micro',
    impactLevel: 'low',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'micro_pickup_1_object',
    category: 'organizing',
    title: 'Recoge 1 objeto',
    description: 'Encuentra 1 objeto que est√© fuera de su sitio y col√≥calo donde va',
    estimatedMinutes: 1,
    effortLevel: 'micro',
    impactLevel: 'low',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'micro_empty_one_trash',
    category: 'cleaning',
    title: 'Vac√≠a una papelera',
    description: 'Elige una papelera de la casa y vac√≠ala',
    estimatedMinutes: 2,
    effortLevel: 'micro',
    impactLevel: 'low',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'micro_clear_counter_spot',
    category: 'organizing',
    room: 'kitchen',
    title: 'Despeja un espacio de encimera',
    description: 'Elige 30cm de encimera y deja esa zona completamente despejada',
    estimatedMinutes: 3,
    effortLevel: 'micro',
    impactLevel: 'medium',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  // ========= TAREAS DE BAJO ESFUERZO =========
  {
    id: 'low_make_bed',
    category: 'organizing',
    room: 'bedroom',
    title: 'Hacer la cama',
    description: 'Estira las s√°banas y coloca la almohada',
    estimatedMinutes: 3,
    effortLevel: 'low',
    impactLevel: 'high', // ¬°Gran impacto visual!
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'low_wipe_kitchen_counter',
    category: 'cleaning',
    room: 'kitchen',
    title: 'Pasar bayeta a encimera',
    description: 'Limpia la encimera de la cocina con una bayeta',
    estimatedMinutes: 5,
    effortLevel: 'low',
    impactLevel: 'medium',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'low_wash_visible_dishes',
    category: 'cleaning',
    room: 'kitchen',
    title: 'Lavar platos visibles',
    description: 'Lava los platos que est√©n a la vista en la cocina',
    estimatedMinutes: 10,
    effortLevel: 'low',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  // ========= TAREAS SIN MOVIMIENTO (para baja energ√≠a) =========
  {
    id: 'nomove_shopping_list',
    category: 'shopping',
    title: 'Hacer lista de compra',
    description: 'Revisa mentalmente qu√© necesitas y a√±√°delo a la lista',
    estimatedMinutes: 10,
    effortLevel: 'low',
    impactLevel: 'medium',
    isMicroTask: false,
    requiresDecisions: true,
    requiresMovement: false, // ¬°Desde el sof√°!
  },
  
  {
    id: 'nomove_meal_planning',
    category: 'organizing',
    title: 'Planificar men√∫ de ma√±ana',
    description: 'Decide qu√© vas a comer ma√±ana',
    estimatedMinutes: 5,
    effortLevel: 'low',
    impactLevel: 'low',
    isMicroTask: false,
    requiresDecisions: true,
    requiresMovement: false,
  },
  
  // ========= TAREAS CON NIVELES DE INTENSIDAD =========
  {
    id: 'multi_clean_bathroom',
    category: 'cleaning',
    room: 'bathroom',
    title: 'Limpiar ba√±o',
    description: 'Limpieza del ba√±o',
    estimatedMinutes: 15, // nivel est√°ndar
    effortLevel: 'medium',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
    intensityLevels: {
      basic: {
        description: 'Solo WC y lavabo',
        minutes: 5,
      },
      standard: {
        description: 'WC, lavabo y ducha',
        minutes: 15,
      },
      deep: {
        description: 'Todo + azulejos y suelo',
        minutes: 30,
      },
    },
  },
  
  {
    id: 'multi_clean_kitchen',
    category: 'cleaning',
    room: 'kitchen',
    title: 'Limpiar cocina',
    description: 'Limpieza de cocina',
    estimatedMinutes: 15,
    effortLevel: 'medium',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
    intensityLevels: {
      basic: {
        description: 'Recoger encimera + fregar platos',
        minutes: 10,
      },
      standard: {
        description: 'B√°sico + pasar bayeta + basura',
        minutes: 20,
      },
      deep: {
        description: 'Todo + electrodom√©sticos + suelo',
        minutes: 40,
      },
    },
  },
  
  // ========= TAREAS DE ALTO IMPACTO (para energ√≠a alta) =========
  {
    id: 'high_vacuum_home',
    category: 'cleaning',
    title: 'Aspirar la casa',
    description: 'Pasar aspiradora por todas las habitaciones',
    estimatedMinutes: 25,
    effortLevel: 'medium',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'high_laundry_cycle',
    category: 'maintenance',
    title: 'Hacer una colada completa',
    description: 'Lavar, tender y recoger ropa',
    estimatedMinutes: 90, // tiempo total distribuido
    effortLevel: 'high',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: true,
    requiresMovement: true,
  },
];

GENERACI√ìN DIN√ÅMICA DE TAREAS
Algunas tareas se generan en tiempo real seg√∫n el estado del hogar:

/**
 * Genera tareas din√°micas basadas en el estado actual
 */
function generateDynamicTasks(homeConfig: HomeConfig): Task[] {
  const dynamicTasks: Task[] = [];
  
  // Para cada habitaci√≥n que necesita atenci√≥n
  homeConfig.rooms.forEach(room => {
    const daysSinceClean = room.lastCleaned 
      ? daysSince(room.lastCleaned) 
      : 999;
    
    if (daysSinceClean > 3) {
      // Generar micro-tarea espec√≠fica para esa habitaci√≥n
      dynamicTasks.push({
        id: `dynamic_tidy_${room.id}`,
        category: 'organizing',
        room: room.id as any,
        title: `Recoger ${room.name}`,
        description: `Dedica 10 minutos a recoger ${room.name}`,
        estimatedMinutes: 10,
        effortLevel: 'low',
        impactLevel: room.priority === 'high' ? 'high' : 'medium',
        isMicroTask: false,
        requiresDecisions: false,
        requiresMovement: true,
      });
    }
  });
  
  return dynamicTasks;
}

INTEGRACI√ìN: LISTA DE COMPRAS INTELIGENTE


/**
 * Sugerencias inteligentes de compras
 */
class ShoppingListEngine {
  
  async generateSuggestions(
    userId: string,
    shoppingList: ShoppingList
  ): Promise<string[]> {
    
    const suggestions: string[] = [];
    
    // Iterar sobre items frecuentes
    shoppingList.frequentItems.forEach(item => {
      const daysSinceLast = item.lastPurchased 
        ? daysSince(item.lastPurchased)
        : 999;
      
      // Si han pasado los d√≠as promedio ¬± 2 d√≠as
      if (daysSinceLast >= item.averageDaysBetweenPurchases - 2) {
        
        // Solo sugerir si NO est√° ya en la lista
        const alreadyInList = shoppingList.items.some(
          i => i.name.toLowerCase() === item.name.toLowerCase()
        );
        
        if (!alreadyInList) {
          suggestions.push(item.name);
        }
      }
    });
    
    // B√°sicos (si no est√°n en lista ni en historial reciente)
    const essentials = ['leche', 'pan', 'huevos', 'agua'];
    essentials.forEach(essential => {
      const inList = shoppingList.items.some(
        i => i.name.toLowerCase().includes(essential)
      );
      const inSuggestions = suggestions.some(
        s => s.toLowerCase().includes(essential)
      );
      
      if (!inList && !inSuggestions) {
        // Verificar si fue comprado recientemente
        const recentPurchase = await checkRecentPurchase(userId, essential);
        if (!recentPurchase) {
          suggestions.push(essential);
        }
      }
    });
    
    return suggestions;
  }
}


SISTEMA DE PUNTOS SEMANAL

/**
 * Calcula y asigna puntos por actividades
 */
function calculateTaskPoints(task: Task, intensityChosen?: string): number {
  let basePoints = 0;
  
  // Puntos base seg√∫n esfuerzo
  switch (task.effortLevel) {
    case 'micro': basePoints = 1; break;
    case 'low': basePoints = 2; break;
    case 'medium': basePoints = 3; break;
    case 'high': basePoints = 5; break;
  }
  
  // Ajustar por intensidad elegida
  if (task.intensityLevels && intensityChosen) {
    switch (intensityChosen) {
      case 'basic': basePoints *= 0.7; break;
      case 'standard': basePoints *= 1.0; break;
      case 'deep': basePoints *= 1.5; break;
    }
  }
  
  // Bonus por impacto
  if (task.impactLevel === 'high') {
    basePoints += 1;
  }
  
  return Math.round(basePoints);
}

/**
 * Actualiza puntos de la semana
 */
async function updateWeeklyPoints(
  userId: string,
  taskCompleted: Task,
  intensityChosen?: string
) {
  const homeConfig = await getHomeConfig(userId);
  
  const points = calculateTaskPoints(taskCompleted, intensityChosen);
  
  homeConfig.currentWeekPoints += points;
  
  // Actualizar puntos de la habitaci√≥n si aplica
  if (taskCompleted.room) {
    const room = homeConfig.rooms.find(r => r.id === taskCompleted.room);
    if (room) {
      room.maintenancePoints += points;
      room.lastCleaned = new Date();
    }
  }
  
  await saveHomeConfig(homeConfig);
  
  // Verificar si alcanz√≥ meta semanal
  if (homeConfig.currentWeekPoints >= homeConfig.weeklyPointsGoal) {
    await showWeeklyGoalAchievement(userId);
  }
}

/**
 * Reset semanal (ejecutar con cron job)
 */
async function resetWeeklyPoints(userId: string) {
  const homeConfig = await getHomeConfig(userId);
  
  // Guardar historial
  await saveWeeklyHistory({
    userId,
    weekStart: getWeekStart(),
    pointsAchieved: homeConfig.currentWeekPoints,
    goalMet: homeConfig.currentWeekPoints >= homeConfig.weeklyPointsGoal,
  });
  
  // Reset
  homeConfig.currentWeekPoints = 0;
  await saveHomeConfig(homeConfig);
}
``


## ESTRUCTURA DE ARCHIVOS DEL PROYECTO
```
/src
  /features
    /home-management
      /components
        - HomeManagementEntry.tsx
        - TaskSuggestion.tsx
        - TaskFeedback.tsx
        - StateCard.tsx
        - TaskCard.tsx
        - MoodComparison.tsx
        - IntensitySelector.tsx
        
      /engine
        - TaskRecommendationEngine.ts
        - ShoppingListEngine.ts
        - PatternLearning.ts
        
      /data
        - tasks-library.ts
        - task-types.ts
        
      /hooks
        - useTaskRecommendation.ts
        - useActivityTracking.ts
        - useUserPatterns.ts
        
      /utils
        - scoring.ts
        - time-utils.ts
        
  /db
    /schemas
      - user-state.schema.ts
      - activity-log.schema.ts
      - user-patterns.schema.ts
      - home-config.schema.ts
      - shopping-list.schema.ts


