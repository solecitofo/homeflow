3. M√ìDULOS DE SOPORTE (no invasivos)
A) Lista de compra inteligente
Problema TDAH: Olvidan qu√© necesitan, van sin lista, compran de m√°s o de menos
Soluci√≥n:
üõí Lista de compra

[A√±adir art√≠culo por voz]  ‚Üê Reducci√≥n fricci√≥n
[A√±adir por foto]          ‚Üê Para embalajes vac√≠os
[A√±adir por texto]

---

üí° Sugerencias basadas en:
- Compras frecuentes
- Tiempo desde √∫ltima compra
- Recordatorio de b√°sicos

¬øNecesitas...?
‚òê Leche (hace 8 d√≠as que no la a√±ades)
‚òê Pan
‚òê Huevos

[A√±adir sugeridas]

Plus: Opci√≥n de compartir lista con convivientes (reducir carga mental)

B) Rutinas de limpieza flexibles
Problema TDAH: Las rutinas r√≠gidas fracasan, generan culpa
Soluci√≥n: Rutinas con variabilidad estructurada

üè† Mantenimiento semanal

En lugar de "todos los lunes limpia ba√±o":

üìä Sistema de puntos semanales:

Necesitas 10 puntos esta semana:
- Limpiar ba√±o: 4 pts
- Aspirar: 3 pts  
- Quitar polvo: 2 pts
- Cambiar s√°banas: 3 pts
- Limpiar cocina: 4 pts

Llevas: 6/10 pts

[Ver tareas disponibles]

Ventaja:

Flexibilidad (eliges qu√© y cu√°ndo)
Control (ves progreso)
Reduce culpa (no es "no hice X d√≠a", es "llevo X puntos")

Plus: Niveles de profundidad
Limpiar ba√±o:
üü¢ Nivel b√°sico (5 min): wc + lavabo
üü° Nivel est√°ndar (15 min): + ducha
üî¥ Nivel profundo (30 min): + azulejos

C) "Habitaci√≥n por habitaci√≥n"
Problema: Ver toda la casa genera abrumaci√≥n
Soluci√≥n: Vista fragmentada + gamificaci√≥n sutil
üè† Estado de tu hogar

üü¢ Cocina (mantenida hoy)
üü° Sal√≥n (√∫ltima vez: hace 2 d√≠as)  
üî¥ Dormitorio (necesita atenci√≥n)
‚ö™ Ba√±o (sin datos)

[Trabajar en dormitorio]

Al entrar a una habitaci√≥n:
üõèÔ∏è Dormitorio

Misiones r√°pidas disponibles:
- Hacer cama (2 min)
- Recoger ropa suelo (5 min)
- Ordenar mesita noche (3 min)

[Hacer una] [Hacer todas]

4. SISTEMA DE REGISTRO Y FEEDBACK
Cr√≠tico para TCC: Conexi√≥n actividad ‚Üî estado de √°nimo
Despu√©s de cada tarea:

‚ú® ¬°Completado!

¬øC√≥mo te sientes AHORA vs ANTES?

Antes: üò∞ Ansioso/a
Ahora: 
[üòå M√°s tranquilo/a]
[üòä Mejor]  
[üòê Igual]
[üòì Peor]

[Siguiente]

En resumen semanal:
üìä Tu semana

Tareas completadas: 12
D√≠as activos: 5/7

üí° Insight:

"Cuando haces micro-tareas de cocina, 
tu estado de √°nimo mejora en un 85% 
de las veces"

"Las ma√±anas son tu mejor momento 
para activarte"



MODELO DE DATOS
Necesitamos capturar informaci√≥n que permita al sistema tomar decisiones inteligentes:

// ESTADO DEL USUARIO (snapshot actual)
interface UserState {
  timestamp: Date;
  emotionalState: 'overwhelmed' | 'energized' | 'stuck' | 'neutral';
  availableTime?: number; // minutos estimados
  energyLevel?: 'low' | 'medium' | 'high';
  barrier?: 'no_energy' | 'dont_know_what' | 'perfectionism' | 'anxiety';
}

// TAREA/ACTIVIDAD
interface Task {
  id: string;
  category: 'cleaning' | 'organizing' | 'shopping' | 'maintenance';
  room?: 'kitchen' | 'bedroom' | 'bathroom' | 'living_room';
  title: string;
  description: string;
  
  // Metadata para el motor de decisi√≥n
  estimatedMinutes: number;
  effortLevel: 'micro' | 'low' | 'medium' | 'high'; // 2min | 5-10min | 15-20min | 30+min
  impactLevel: 'low' | 'medium' | 'high'; // impacto visual/emocional
  
  // Para micro-tareas
  isMicroTask: boolean;
  parentTaskId?: string; // si es parte de una tarea mayor
  
  // Complejidad cognitiva
  requiresDecisions: boolean; // ¬øhay que tomar decisiones mientras se hace?
  requiresMovement: boolean; // ¬ørequiere moverse/esfuerzo f√≠sico?
  
  // Configuraci√≥n de intensidad
  intensityLevels?: {
    basic: { description: string; minutes: number };
    standard: { description: string; minutes: number };
    deep: { description: string; minutes: number };
  };
}

// REGISTRO DE ACTIVIDAD
interface ActivityLog {
  id: string;
  userId: string;
  taskId: string;
  
  // Estado pre-tarea
  startTime: Date;
  startEmotionalState: EmotionalState;
  startEnergyLevel?: number; // 1-10
  
  // Estado durante
  completed: boolean;
  actualMinutes?: number;
  interrupted?: boolean;
  intensityChosen?: 'basic' | 'standard' | 'deep';
  
  // Estado post-tarea
  endTime?: Date;
  endEmotionalState?: EmotionalState;
  endEnergyLevel?: number;
  satisfactionRating?: number; // 1-5
  
  // Metadata
  triggeredBy: 'user_choice' | 'system_suggestion' | 'scheduled';
  routeUsed: 'overwhelmed' | 'energized' | 'stuck' | 'planned';
}

// ESTADO EMOCIONAL (m√°s granular)
interface EmotionalState {
  mood: 'very_bad' | 'bad' | 'neutral' | 'good' | 'very_good';
  anxiety?: number; // 1-10
  overwhelm?: number; // 1-10
  motivation?: number; // 1-10
}

// PATRONES DETECTADOS (aprendizaje del sistema)
interface UserPatterns {
  userId: string;
  
  // Ventanas de activaci√≥n
  bestTimeOfDay?: 'morning' | 'afternoon' | 'evening';
  bestDayOfWeek?: string[];
  
  // Tareas con mejor impacto emocional
  highImpactTasks: {
    taskId: string;
    averageMoodImprovement: number;
    completionRate: number;
  }[];
  
  // Preferencias detectadas
  preferredTaskDuration: number; // promedio
  avoidsTasksWith: string[]; // caracter√≠sticas que evita
  
  // Racha actual
  currentStreak: number;
  longestStreak: number;
  lastActivityDate: Date;
}

// CONFIGURACI√ìN DE HOGAR
interface HomeConfig {
  userId: string;
  rooms: {
    id: string;
    name: string;
    priority: 'high' | 'medium' | 'low';
    lastCleaned?: Date;
    maintenancePoints: number; // sistema de puntos
  }[];
  
  weeklyPointsGoal: number; // default: 10
  currentWeekPoints: number;
}

// LISTA DE COMPRAS
interface ShoppingList {
  userId: string;
  items: {
    id: string;
    name: string;
    addedAt: Date;
    addedBy: 'user' | 'suggestion';
    category?: string;
    checked: boolean;
  }[];
  
  // Historial para sugerencias
  frequentItems: {
    name: string;
    averageDaysBetweenPurchases: number;
    lastPurchased?: Date;
  }[];
}

MOTOR DE DECISI√ìN: L√ìGICA DE RECOMENDACI√ìN
Este es el cerebro del sistema. Decide qu√© sugerir seg√∫n el contexto.
Algoritmo de Recomendaci√≥n

class TaskRecommendationEngine {
  
  /**
   * Funci√≥n principal: recomienda tarea seg√∫n estado del usuario
   */
  async recommendTask(
    userState: UserState,
    userPatterns: UserPatterns,
    homeConfig: HomeConfig,
    activityHistory: ActivityLog[]
  ): Promise<Task> {
    
    // PASO 1: Determinar estrategia TCC seg√∫n estado emocional
    const strategy = this.selectTCCStrategy(userState);
    
    // PASO 2: Filtrar tareas disponibles seg√∫n estrategia
    const candidateTasks = await this.filterTasksByStrategy(
      strategy,
      userState,
      homeConfig
    );
    
    // PASO 3: Scoring de tareas seg√∫n m√∫ltiples criterios
    const scoredTasks = this.scoreTasks(
      candidateTasks,
      userState,
      userPatterns,
      activityHistory
    );
    
    // PASO 4: Seleccionar la mejor opci√≥n
    return scoredTasks[0];
  }
  
  /**
   * PASO 1: Seleccionar estrategia TCC
   */
  private selectTCCStrategy(userState: UserState): TCCStrategy {
    
    // RUTA A: Usuario abrumado
    if (userState.emotionalState === 'overwhelmed') {
      return {
        name: 'micro_activation',
        principles: [
          'minimize_cognitive_load',
          'immediate_action',
          'no_choice_paralysis'
        ],
        filters: {
          isMicroTask: true,
          maxMinutes: 5,
          requiresDecisions: false,
          effortLevel: 'micro'
        }
      };
    }
    
    // RUTA B: Usuario con energ√≠a
    if (userState.emotionalState === 'energized' && userState.energyLevel === 'high') {
      return {
        name: 'capitalize_activation',
        principles: [
          'maximize_impact',
          'leverage_momentum',
          'high_reinforcement_tasks'
        ],
        filters: {
          maxMinutes: userState.availableTime || 20,
          impactLevel: ['medium', 'high'],
          // Priorizar tareas que hist√≥ricamente generan satisfacci√≥n
        }
      };
    }
    
    // RUTA C: Usuario bloqueado/estancado
    if (userState.emotionalState === 'stuck') {
      
      // Sub-estrategia seg√∫n la barrera espec√≠fica
      if (userState.barrier === 'no_energy') {
        return {
          name: 'low_effort_activation',
          principles: ['minimize_physical_effort', 'mental_tasks_ok'],
          filters: {
            requiresMovement: false,
            effortLevel: ['micro', 'low'],
            category: ['organizing', 'shopping'] // planificar, no ejecutar
          }
        };
      }
      
      if (userState.barrier === 'dont_know_what') {
        return {
          name: 'remove_choice',
          principles: ['provide_direction', 'random_ok'],
          filters: {
            // Cualquier tarea de bajo esfuerzo
            effortLevel: ['micro', 'low']
          }
        };
      }
      
      if (userState.barrier === 'perfectionism') {
        return {
          name: 'challenge_perfectionism',
          principles: ['emphasize_progress_over_perfection', 'time_boxing'],
          filters: {
            // Tareas con niveles de intensidad claros
            intensityLevels: 'exists'
          },
          messaging: {
            preTask: 'Recuerda: solo vas a hacer el nivel B√ÅSICO. Hecho es mejor que perfecto.',
            emphasizeBasicLevel: true
          }
        };
      }
      
      if (userState.barrier === 'anxiety') {
        return {
          name: 'reduce_anxiety',
          principles: ['familiar_tasks', 'high_success_rate'],
          filters: {
            // Tareas que el usuario ha completado antes con √©xito
            previouslyCompleted: true,
            effortLevel: ['micro', 'low']
          }
        };
      }
    }
    
    // RUTA D: Estado neutral / planificaci√≥n
    return {
      name: 'planned_activation',
      principles: ['user_directed', 'show_options'],
      filters: {} // Sin filtros restrictivos
    };
  }
  
  /**
   * PASO 2: Filtrar tareas disponibles
   */
  private async filterTasksByStrategy(
    strategy: TCCStrategy,
    userState: UserState,
    homeConfig: HomeConfig
  ): Promise<Task[]> {
    
    let allTasks = await this.getAllAvailableTasks(homeConfig);
    
    // Aplicar filtros de la estrategia
    let filtered = allTasks.filter(task => {
      
      // Filtro: micro-tareas
      if (strategy.filters.isMicroTask !== undefined) {
        if (task.isMicroTask !== strategy.filters.isMicroTask) return false;
      }
      
      // Filtro: duraci√≥n m√°xima
      if (strategy.filters.maxMinutes) {
        if (task.estimatedMinutes > strategy.filters.maxMinutes) return false;
      }
      
      // Filtro: nivel de esfuerzo
      if (strategy.filters.effortLevel) {
        const allowedLevels = Array.isArray(strategy.filters.effortLevel) 
          ? strategy.filters.effortLevel 
          : [strategy.filters.effortLevel];
        if (!allowedLevels.includes(task.effortLevel)) return false;
      }
      
      // Filtro: requiere decisiones
      if (strategy.filters.requiresDecisions === false) {
        if (task.requiresDecisions) return false;
      }
      
      // Filtro: requiere movimiento
      if (strategy.filters.requiresMovement === false) {
        if (task.requiresMovement) return false;
      }
      
      // Filtro: categor√≠as espec√≠ficas
      if (strategy.filters.category) {
        const allowedCategories = Array.isArray(strategy.filters.category)
          ? strategy.filters.category
          : [strategy.filters.category];
        if (!allowedCategories.includes(task.category)) return false;
      }
      
      // Filtro: nivel de impacto
      if (strategy.filters.impactLevel) {
        const allowedImpacts = Array.isArray(strategy.filters.impactLevel)
          ? strategy.filters.impactLevel
          : [strategy.filters.impactLevel];
        if (!allowedImpacts.includes(task.impactLevel)) return false;
      }
      
      // Filtro: tiene niveles de intensidad
      if (strategy.filters.intensityLevels === 'exists') {
        if (!task.intensityLevels) return false;
      }
      
      return true;
    });
    
    return filtered;
  }
  
  /**
   * PASO 3: Scoring de tareas (Machine Learning light)
   */
  private scoreTasks(
    tasks: Task[],
    userState: UserState,
    userPatterns: UserPatterns,
    activityHistory: ActivityLog[]
  ): Task[] {
    
    const scoredTasks = tasks.map(task => {
      let score = 0;
      
      // Factor 1: Historial de impacto emocional (PESO ALTO)
      const taskPattern = userPatterns.highImpactTasks.find(
        p => p.taskId === task.id
      );
      if (taskPattern) {
        score += taskPattern.averageMoodImprovement * 30; // peso x30
        score += taskPattern.completionRate * 20; // peso x20
      }
      
      // Factor 2: Alineaci√≥n con patrones temporales
      const currentHour = new Date().getHours();
      if (userPatterns.bestTimeOfDay) {
        const isOptimalTime = this.checkOptimalTime(currentHour, userPatterns.bestTimeOfDay);
        if (isOptimalTime) score += 15;
      }
      
      // Factor 3: Urgencia (√∫ltima vez realizada)
      const room = task.room;
      if (room) {
        const roomConfig = homeConfig.rooms.find(r => r.id === room);
        if (roomConfig?.lastCleaned) {
          const daysSince = this.daysSince(roomConfig.lastCleaned);
          score += Math.min(daysSince * 2, 20); // max 20 puntos
        }
      }
      
      // Factor 4: Impacto visual/emocional
      if (task.impactLevel === 'high') score += 15;
      if (task.impactLevel === 'medium') score += 8;
      
      // Factor 5: Duraci√≥n vs tiempo disponible (ajuste perfecto)
      if (userState.availableTime) {
        const timeFit = Math.abs(task.estimatedMinutes - userState.availableTime);
        score += Math.max(10 - timeFit, 0); // penaliza desajuste
      }
      
      // Factor 6: Evitar tareas recientemente completadas (variedad)
      const recentlyDone = activityHistory
        .filter(log => log.taskId === task.id)
        .sort((a, b) => b.startTime.getTime() - a.startTime.getTime())[0];
      
      if (recentlyDone) {
        const hoursSince = this.hoursSince(recentlyDone.startTime);
        if (hoursSince < 24) score -= 20; // penaliza mucho
        else if (hoursSince < 72) score -= 10; // penaliza moderado
      }
      
      // Factor 7: Preferencia de duraci√≥n detectada
      if (userPatterns.preferredTaskDuration) {
        const durationDiff = Math.abs(task.estimatedMinutes - userPatterns.preferredTaskDuration);
        score += Math.max(10 - durationDiff / 2, 0);
      }
      
      return { task, score };
    });
    
    // Ordenar por score descendente
    return scoredTasks
      .sort((a, b) => b.score - a.score)
      .map(item => item.task);
  }
  
  /**
   * M√©todos auxiliares
   */
  private async getAllAvailableTasks(homeConfig: HomeConfig): Promise<Task[]> {
    // Combina:
    // 1. Tareas predefinidas del sistema (biblioteca de tareas)
    // 2. Tareas personalizadas del usuario
    // 3. Tareas generadas din√°micamente seg√∫n estado del hogar
  }
  
  private daysSince(date: Date): number {
    return Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60 * 24));
  }
  
  private hoursSince(date: Date): number {
    return Math.floor((Date.now() - date.getTime()) / (1000 * 60 * 60));
  }
  
  private checkOptimalTime(currentHour: number, bestTime: string): boolean {
    const ranges = {
      morning: [6, 12],
      afternoon: [12, 18],
      evening: [18, 23]
    };
    const [start, end] = ranges[bestTime];
    return currentHour >= start && currentHour < end;
  }
}

FLUJO DE INTERACCI√ìN USUARIO-SISTEMA
Pantalla de entrada

// Componente: HomeManagementEntry.tsx

function HomeManagementEntry() {
  const [userState, setUserState] = useState<UserState | null>(null);
  
  const handleStateSelection = async (emotionalState: string) => {
    
    // Capturar estado inicial
    const state: UserState = {
      timestamp: new Date(),
      emotionalState: emotionalState as any,
    };
    
    // Si es "energized" o "stuck", hacer preguntas de seguimiento
    if (emotionalState === 'energized') {
      // Modal: "¬øCu√°nto tiempo tienes?"
      const time = await askAvailableTime();
      state.availableTime = time;
      state.energyLevel = 'high';
    }
    
    if (emotionalState === 'stuck') {
      // Modal: "¬øQu√© te est√° frenando?"
      const barrier = await askBarrier();
      state.barrier = barrier;
    }
    
    setUserState(state);
    
    // Obtener recomendaci√≥n del motor
    const recommendation = await getTaskRecommendation(state);
    
    // Navegar a pantalla de tarea recomendada
    navigate('/home/task-suggestion', { state: { recommendation, userState: state } });
  };
  
  return (
    <div className="entry-screen">
      <h2>¬øC√≥mo puedo ayudarte hoy?</h2>
      
      <StateCard 
        icon="ü§Ø"
        title="Estoy abrumado/a"
        subtitle="No s√© ni por d√≥nde empezar"
        onClick={() => handleStateSelection('overwhelmed')}
      />
      
      <StateCard 
        icon="‚ö°"
        title="Tengo algo de energ√≠a"
        subtitle="¬øQu√© puedo hacer?"
        onClick={() => handleStateSelection('energized')}
      />
      
      <StateCard 
        icon="üòì"
        title="Me cuesta ponerme en marcha"
        subtitle="Necesito un empuj√≥n"
        onClick={() => handleStateSelection('stuck')}
      />
      
      <StateCard 
        icon="üìù"
        title="Quiero planificar"
        subtitle="Ver opciones y decidir"
        onClick={() => navigate('/home/overview')}
      />
    </div>
  );
}

Pantalla de tarea sugerida

// Componente: TaskSuggestion.tsx

function TaskSuggestion() {
  const { recommendation, userState } = useLocation().state;
  const [taskStarted, setTaskStarted] = useState(false);
  const [timer, setTimer] = useState<number>(0);
  
  const handleStart = async () => {
    // Registrar inicio de actividad
    const activityLog: ActivityLog = {
      id: generateId(),
      userId: currentUser.id,
      taskId: recommendation.id,
      startTime: new Date(),
      startEmotionalState: await captureEmotionalState(),
      triggeredBy: 'system_suggestion',
      routeUsed: userState.emotionalState,
      completed: false,
    };
    
    await saveActivityLog(activityLog);
    
    setTaskStarted(true);
    startTimer(recommendation.estimatedMinutes);
  };
  
  const handleComplete = async () => {
    // Registrar finalizaci√≥n
    const endState = await captureEmotionalState();
    
    await updateActivityLog({
      completed: true,
      endTime: new Date(),
      actualMinutes: timer,
      endEmotionalState: endState,
    });
    
    // Mostrar feedback
    navigate('/home/task-feedback', { state: { activityLog } });
  };
  
  return (
    <div className="task-suggestion">
      {/* Mensaje personalizado seg√∫n estrategia TCC */}
      <TCCMessage strategy={recommendation.strategy} />
      
      <TaskCard task={recommendation} />
      
      {/* Si es estrategia de perfeccionismo */}
      {recommendation.strategy === 'challenge_perfectionism' && (
        <IntensitySelector 
          levels={recommendation.intensityLevels}
          defaultLevel="basic"
          emphasizeBasic={true}
        />
      )}
      
      {!taskStarted ? (
        <>
          <Button onClick={handleStart}>Empezar</Button>
          <Button variant="secondary" onClick={askForAlternative}>
            Dame otra opci√≥n
          </Button>
          {userState.emotionalState === 'overwhelmed' && (
            <Button variant="text" onClick={requestSmallerTask}>
              Necesito algo m√°s peque√±o
            </Button>
          )}
        </>
      ) : (
        <>
          <Timer minutes={timer} />
          <Checklist items={recommendation.steps} />
          <Button onClick={handleComplete}>¬°Hecho!</Button>
        </>
      )}
    </div>
  );
}

Pantalla de feedback post-tarea

// Componente: TaskFeedback.tsx

function TaskFeedback() {
  const { activityLog } = useLocation().state;
  
  const handleFeedback = async (feedback: FeedbackData) => {
    // Actualizar log con satisfacci√≥n y estado final
    await updateActivityLog({
      ...activityLog,
      satisfactionRating: feedback.satisfaction,
      endEnergyLevel: feedback.energyLevel,
    });
    
    // Actualizar patrones del usuario
    await updateUserPatterns(activityLog, feedback);
    
    // Preguntar si quiere hacer otra tarea
    showNextActionPrompt();
  };
  
  return (
    <div className="task-feedback">
      <SuccessAnimation />
      
      <h2>‚ú® ¬°Lo hiciste!</h2>
      
      <p>Completaste: {activityLog.task.title}</p>
      <p>en {activityLog.actualMinutes} minutos</p>
      
      <MoodComparison 
        before={activityLog.startEmotionalState}
        after={activityLog.endEmotionalState}
      />
      
      <FeedbackForm onSubmit={handleFeedback} />
      
      <StreakIndicator currentStreak={currentStreak} />
    </div>
  );
}

APRENDIZAJE CONTINUO DEL SISTEMA


/**
 * Actualiza los patrones del usuario despu√©s de cada actividad
 */
async function updateUserPatterns(
  activityLog: ActivityLog,
  feedback: FeedbackData
) {
  const patterns = await getUserPatterns(activityLog.userId);
  
  // 1. Detectar ventanas de activaci√≥n √≥ptimas
  const hour = activityLog.startTime.getHours();
  const timeOfDay = getTimeOfDay(hour);
  
  if (activityLog.completed && feedback.satisfaction >= 4) {
    patterns.successfulTimeSlots = patterns.successfulTimeSlots || {};
    patterns.successfulTimeSlots[timeOfDay] = 
      (patterns.successfulTimeSlots[timeOfDay] || 0) + 1;
  }
  
  // 2. Actualizar tareas de alto impacto
  if (feedback.moodImprovement > 0) {
    const taskPattern = patterns.highImpactTasks.find(
      t => t.taskId === activityLog.taskId
    );
    
    if (taskPattern) {
      // Actualizar promedio m√≥vil
      taskPattern.averageMoodImprovement = 
        (taskPattern.averageMoodImprovement * 0.8) + (feedback.moodImprovement * 0.2);
    } else {
      patterns.highImpactTasks.push({
        taskId: activityLog.taskId,
        averageMoodImprovement: feedback.moodImprovement,
        completionRate: 1.0,
      });
    }
  }
  
  // 3. Detectar duraci√≥n preferida
  if (activityLog.completed) {
    patterns.taskDurations = patterns.taskDurations || [];
    patterns.taskDurations.push(activityLog.actualMinutes);
    
    // Calcular mediana de las √∫ltimas 10 tareas
    if (patterns.taskDurations.length > 10) {
      patterns.preferredTaskDuration = median(patterns.taskDurations.slice(-10));
    }
  }
  
  // 4. Actualizar racha
  const today = new Date().toDateString();
  const lastActivity = patterns.lastActivityDate?.toDateString();
  
  if (lastActivity === today) {
    // Mismo d√≠a, no cambiar racha
  } else if (wasYesterday(patterns.lastActivityDate)) {
    patterns.currentStreak += 1;
    patterns.longestStreak = Math.max(patterns.currentStreak, patterns.longestStreak);
  } else {
    patterns.currentStreak = 1; // Reset
  }
  
  patterns.lastActivityDate = new Date();
  
  await saveUserPatterns(patterns);
}

BIBLIOTECA DE TAREAS PREDEFINIDAS

// tasks-library.ts

export const TASKS_LIBRARY: Task[] = [
  // ========= MICRO-TAREAS (para estado "overwhelmed") =========
  {
    id: 'micro_pickup_3_objects',
    category: 'organizing',
    title: 'Recoge 3 objetos',
    description: 'Encuentra 3 objetos que est√©n fuera de su sitio y col√≥calos donde van',
    estimatedMinutes: 2,
    effortLevel: 'micro',
    impactLevel: 'low',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'micro_pickup_1_object',
    category: 'organizing',
    title: 'Recoge 1 objeto',
    description: 'Encuentra 1 objeto que est√© fuera de su sitio y col√≥calo donde va',
    estimatedMinutes: 1,
    effortLevel: 'micro',
    impactLevel: 'low',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'micro_empty_one_trash',
    category: 'cleaning',
    title: 'Vac√≠a una papelera',
    description: 'Elige una papelera de la casa y vac√≠ala',
    estimatedMinutes: 2,
    effortLevel: 'micro',
    impactLevel: 'low',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'micro_clear_counter_spot',
    category: 'organizing',
    room: 'kitchen',
    title: 'Despeja un espacio de encimera',
    description: 'Elige 30cm de encimera y deja esa zona completamente despejada',
    estimatedMinutes: 3,
    effortLevel: 'micro',
    impactLevel: 'medium',
    isMicroTask: true,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  // ========= TAREAS DE BAJO ESFUERZO =========
  {
    id: 'low_make_bed',
    category: 'organizing',
    room: 'bedroom',
    title: 'Hacer la cama',
    description: 'Estira las s√°banas y coloca la almohada',
    estimatedMinutes: 3,
    effortLevel: 'low',
    impactLevel: 'high', // ¬°Gran impacto visual!
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'low_wipe_kitchen_counter',
    category: 'cleaning',
    room: 'kitchen',
    title: 'Pasar bayeta a encimera',
    description: 'Limpia la encimera de la cocina con una bayeta',
    estimatedMinutes: 5,
    effortLevel: 'low',
    impactLevel: 'medium',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'low_wash_visible_dishes',
    category: 'cleaning',
    room: 'kitchen',
    title: 'Lavar platos visibles',
    description: 'Lava los platos que est√©n a la vista en la cocina',
    estimatedMinutes: 10,
    effortLevel: 'low',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  // ========= TAREAS SIN MOVIMIENTO (para baja energ√≠a) =========
  {
    id: 'nomove_shopping_list',
    category: 'shopping',
    title: 'Hacer lista de compra',
    description: 'Revisa mentalmente qu√© necesitas y a√±√°delo a la lista',
    estimatedMinutes: 10,
    effortLevel: 'low',
    impactLevel: 'medium',
    isMicroTask: false,
    requiresDecisions: true,
    requiresMovement: false, // ¬°Desde el sof√°!
  },
  
  {
    id: 'nomove_meal_planning',
    category: 'organizing',
    title: 'Planificar men√∫ de ma√±ana',
    description: 'Decide qu√© vas a comer ma√±ana',
    estimatedMinutes: 5,
    effortLevel: 'low',
    impactLevel: 'low',
    isMicroTask: false,
    requiresDecisions: true,
    requiresMovement: false,
  },
  
  // ========= TAREAS CON NIVELES DE INTENSIDAD =========
  {
    id: 'multi_clean_bathroom',
    category: 'cleaning',
    room: 'bathroom',
    title: 'Limpiar ba√±o',
    description: 'Limpieza del ba√±o',
    estimatedMinutes: 15, // nivel est√°ndar
    effortLevel: 'medium',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
    intensityLevels: {
      basic: {
        description: 'Solo WC y lavabo',
        minutes: 5,
      },
      standard: {
        description: 'WC, lavabo y ducha',
        minutes: 15,
      },
      deep: {
        description: 'Todo + azulejos y suelo',
        minutes: 30,
      },
    },
  },
  
  {
    id: 'multi_clean_kitchen',
    category: 'cleaning',
    room: 'kitchen',
    title: 'Limpiar cocina',
    description: 'Limpieza de cocina',
    estimatedMinutes: 15,
    effortLevel: 'medium',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
    intensityLevels: {
      basic: {
        description: 'Recoger encimera + fregar platos',
        minutes: 10,
      },
      standard: {
        description: 'B√°sico + pasar bayeta + basura',
        minutes: 20,
      },
      deep: {
        description: 'Todo + electrodom√©sticos + suelo',
        minutes: 40,
      },
    },
  },
  
  // ========= TAREAS DE ALTO IMPACTO (para energ√≠a alta) =========
  {
    id: 'high_vacuum_home',
    category: 'cleaning',
    title: 'Aspirar la casa',
    description: 'Pasar aspiradora por todas las habitaciones',
    estimatedMinutes: 25,
    effortLevel: 'medium',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: false,
    requiresMovement: true,
  },
  
  {
    id: 'high_laundry_cycle',
    category: 'maintenance',
    title: 'Hacer una colada completa',
    description: 'Lavar, tender y recoger ropa',
    estimatedMinutes: 90, // tiempo total distribuido
    effortLevel: 'high',
    impactLevel: 'high',
    isMicroTask: false,
    requiresDecisions: true,
    requiresMovement: true,
  },
];

GENERACI√ìN DIN√ÅMICA DE TAREAS
Algunas tareas se generan en tiempo real seg√∫n el estado del hogar:

/**
 * Genera tareas din√°micas basadas en el estado actual
 */
function generateDynamicTasks(homeConfig: HomeConfig): Task[] {
  const dynamicTasks: Task[] = [];
  
  // Para cada habitaci√≥n que necesita atenci√≥n
  homeConfig.rooms.forEach(room => {
    const daysSinceClean = room.lastCleaned 
      ? daysSince(room.lastCleaned) 
      : 999;
    
    if (daysSinceClean > 3) {
      // Generar micro-tarea espec√≠fica para esa habitaci√≥n
      dynamicTasks.push({
        id: `dynamic_tidy_${room.id}`,
        category: 'organizing',
        room: room.id as any,
        title: `Recoger ${room.name}`,
        description: `Dedica 10 minutos a recoger ${room.name}`,
        estimatedMinutes: 10,
        effortLevel: 'low',
        impactLevel: room.priority === 'high' ? 'high' : 'medium',
        isMicroTask: false,
        requiresDecisions: false,
        requiresMovement: true,
      });
    }
  });
  
  return dynamicTasks;
}

INTEGRACI√ìN: LISTA DE COMPRAS INTELIGENTE

/**
 * Sugerencias inteligentes de compras
 */
class ShoppingListEngine {
  
  async generateSuggestions(
    userId: string,
    shoppingList: ShoppingList
  ): Promise<string[]> {
    
    const suggestions: string[] = [];
    
    // Iterar sobre items frecuentes
    shoppingList.frequentItems.forEach(item => {
      const daysSinceLast = item.lastPurchased 
        ? daysSince(item.lastPurchased)
        : 999;
      
      // Si han pasado los d√≠as promedio ¬± 2 d√≠as
      if (daysSinceLast >= item.averageDaysBetweenPurchases - 2) {
        
        // Solo sugerir si NO est√° ya en la lista
        const alreadyInList = shoppingList.items.some(
          i => i.name.toLowerCase() === item.name.toLowerCase()
        );
        
        if (!alreadyInList) {
          suggestions.push(item.name);
        }
      }
    });
    
    // B√°sicos (si no est√°n en lista ni en historial reciente)
    const essentials = ['leche', 'pan', 'huevos', 'agua'];
    essentials.forEach(essential => {
      const inList = shoppingList.items.some(
        i => i.name.toLowerCase().includes(essential)
      );
      const inSuggestions = suggestions.some(
        s => s.toLowerCase().includes(essential)
      );
      
      if (!inList && !inSuggestions) {
        // Verificar si fue comprado recientemente
        const recentPurchase = await checkRecentPurchase(userId, essential);
        if (!recentPurchase) {
          suggestions.push(essential);
        }
      }
    });
    
    return suggestions;
  }
}
